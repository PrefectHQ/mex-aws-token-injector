# Webhook Configuration with HELM chart

## Prerequisites
- Container images for `token-injector-webhook`, `token-injector` tool and `certificator` tool (see separate [repository](https://github.com/ealebed/admission-webhook-certificator)) should be built and uploaded to the Container Registry accessible from GKE cluster.
- AWS IAM Role (Web Identity type) should be created as described in [document](aws_role_creation.md)
- GKE cluster with [Workload Identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity) enabled. For this, you can use [Terraform code](../terraform/), as shown below.

### Remove (or comment) unused configuration file
```bash
rm terraform/webhook.tf
```

### Deploy Terraform code
```bash
cd terraform
terraform init
terraform plan
terraform apply
```

### Configure `kubectl` command line access by running the following command
```bash
gcloud container clusters get-credentials ${GKE_CLUSTER_NAME} --region ${GCP_REGION} --project ${PROJECT_ID}
```
For example:
```bash
gcloud container clusters get-credentials regional-cluster-test --region us-west1 --project ylebi-rnd
```

### Deploy HELM chart
```bash
cd ../helm-chart
```

```bash
helm upgrade --install admission-webhook-v1 . --values values.yaml --set apiserverCABundle=$(kubectl config view --raw --minify --flatten -o jsonpath='{.clusters[].cluster.certificate-authority-data}') --namespace webhook
```

### Export ENV variables
```bash
export KSA_NAMESPACE=application-namespace
export KSA_NAME=aws-reader-sa
export GSA_NAME=aws-accessor-sa
export PROJECT_ID=<your_gcp_project_id>
export AWS_ROLE_ARN=<your_aws_role_arn> # E.g.: arn:aws:iam::531438381462:role/gke-reader-role
```

### Get the Google Cloud Service Account unique ID, generated by Google
```bash
gcloud iam service-accounts describe --format json ${GSA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com  | jq -r '.uniqueId'
```

### Add Google Cloud Service Account unique ID into AWS role trust policy document

### GKE: Kubernetes Service Account for application workload
- Create k8s Service Account:
```bash
kubectl create serviceaccount --namespace ${KSA_NAMESPACE} ${KSA_NAME}
```

- Annotate k8s Service Account with GKE Workload Identity (GCP Service Account email)
```bash
kubectl annotate serviceaccount --namespace ${KSA_NAMESPACE} ${KSA_NAME} \
  iam.gke.io/gcp-service-account=${GSA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com
```

- Annotate k8s Service Account with AWS Role ARN:
```bash
kubectl annotate serviceaccount --namespace ${KSA_NAMESPACE} ${KSA_NAME} \
  amazonaws.com/role-arn=${AWS_ROLE_ARN}
```

## Testing
- Create a k8s Pod configuration as shown below:
```bash
cat > test-pod.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: ${KSA_NAMESPACE}
  labels:
    admission.token-injector/enabled: "true"
spec:
  serviceAccountName: ${KSA_NAME}
  containers:
  - name: test-pod
    image: mikesir87/aws-cli
    command: ["tail", "-f", "/dev/null"]
EOF
```

- Apply pod configuration from YAML file:
```bash
kubectl apply -f test-pod.yaml
```

- Connect to the running k8s Pod:
```bash
kubectl exec -it test-pod -n application-namespace -- bash
```

- Run the following command in the Pod shell to check the AWS assumed role:
```bash
aws sts get-caller-identity
```

The output should look similar to the below:
```text
{
    "UserId": "AROAXXPBSFGLKUDFGHT7Q:token-injector-webhook-luwkompqhfewtygb",
    "Account": "531438381462",
    "Arn": "arn:aws:sts::531438381462:assumed-role/gke-reader-role/token-injector-webhook-luwkompqhfewtygb"
}
```
