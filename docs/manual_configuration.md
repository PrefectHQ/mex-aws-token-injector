# Manual Webhook Configuration

## Prerequisites
- Container images for `token-injector-webhook`, `token-injector` tool and `certificator` tool (see separate [repository](https://github.com/ealebed/admission-webhook-certificator)) should be built and uploaded to the Container Registry accessible from GKE cluster.

## Configuration Flow
### Flow variables
- `PROJECT_ID` - GCP project ID
- `CLUSTER_NAME` - GKE cluster name
- `CLUSTER_ZONE` - GKE cluster zone
- `GSA_NAME` - Google Cloud Service Account name (choose any)
- `GSA_ID` - Google Cloud Service Account unique ID (generated by Google)
- `KSA_NAME` - Kubernetes Service Account name (choose any)
- `KSA_NAMESPACE` - Kubernetes namespace for application workload
- `AWS_ROLE_NAME` - AWS IAM role name (choose any)
- `AWS_POLICY_NAME` - AWS IAM policy to assign to IAM role
- `AWS_ROLE_ARN` - AWS IAM Role ARN identifier (generated by AWS)

### GCP: Create GKE cluster
- Create a new GKE cluster with [Workload Identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity) enabled:
```bash
gcloud container clusters create ${CLUSTER_NAME} \
    --zone=${CLUSTER_ZONE} \
    --workload-pool=${PROJECT_ID}.svc.id.goog
```

### GCP: Configure GCP Service Account
- Create Google Cloud Service Account:
```bash
gcloud iam service-accounts create ${GSA_NAME}
```

- Get GCP SA UID to be used for AWS Role with Google OIDC Web Identity
```bash
GSA_ID=$(gcloud iam service-accounts describe --format json ${GSA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com  | jq -r '.uniqueId')
```

- Update `GSA_NAME` Google Service Account with following roles:
  - `roles/iam.workloadIdentityUser` - impersonate service accounts from GKE Workloads
  - `roles/iam.serviceAccountTokenCreator` - impersonate service accounts to create OAuth2 access tokens, sign blobs, or sign JWTs

```bash
gcloud projects add-iam-policy-binding ${PROJECT_ID} \
  --member serviceAccount:${GSA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com \
  --role roles/iam.serviceAccountTokenCreator

gcloud iam service-accounts add-iam-policy-binding \
  --role roles/iam.workloadIdentityUser \
  --member "serviceAccount:${PROJECT_ID}.svc.id.goog[${KSA_NAMESPACE}/${KSA_NAME}]" \
  ${GSA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com
```

### AWS: Create AWS IAM permissions policy
- Prepare the role permissions policy document (JSON) for Google OIDC provider:
```bash
cat > gcp-role-policy.json << EOF
{
  "Version": "2012-10-17",
  "Statement": [
      {
          "Effect": "Allow",
          "Action": [
              "secretsmanager:GetResourcePolicy",
              "secretsmanager:GetSecretValue",
              "secretsmanager:DescribeSecret",
              "secretsmanager:ListSecretVersionIds",
              "secretsmanager:ListSecrets"
          ],
          "Resource": "*"
      }
  ]
}
EOF
```

- Create the AWS IAM permissions policy:
```bash
aws iam create-policy --policy-name ${AWS_POLICY_NAME} --policy-document file://gcp-role-policy.json
```

### AWS: Create an AWS IAM Role with Google OIDC Web Identity using AWS CLI:
- Prepare the role trust policy document (JSON) for Google OIDC provider:
```bash
cat > gcp-trust-policy.json << EOF
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Federated": "accounts.google.com"
      },
      "Action": "sts:AssumeRoleWithWebIdentity",
      "Condition": {
        "StringEquals": {
          "accounts.google.com:aud": "${GSA_ID}"
        }
      }
    }
  ]
}
EOF
```

- Create the AWS IAM Role with Google Web Identity:
```bash
aws iam create-role --role-name ${AWS_ROLE_NAME} --assume-role-policy-document file://gcp-trust-policy.json
```

- Attach the desired policies to the AWS IAM role:
```bash
aws iam attach-role-policy --role-name ${AWS_ROLE_NAME} --policy-arn arn:aws:iam::531438381462:policy/${AWS_POLICY_NAME}
```

- Set the AWS Role ARN to `AWS_ROLE_ARN` environment variable:
```bash
AWS_ROLE_ARN=$(aws iam get-role --role-name ${AWS_ROLE_NAME} --query Role.Arn --output text)
```

### GKE: Kubernetes Namespace
- Create a k8s namespace:
```bash
kubectl create namespace ${KSA_NAMESPACE}
```

### GKE: Kubernetes Service Account
- Create k8s Service Account:
```bash
kubectl create serviceaccount --namespace ${KSA_NAMESPACE} ${KSA_NAME}
```

- Annotate k8s Service Account with GKE Workload Identity (GCP Service Account email)
```bash
kubectl annotate serviceaccount --namespace ${KSA_NAMESPACE} ${KSA_NAME} \
  iam.gke.io/gcp-service-account=${GSA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com
```

- Annotate k8s Service Account with AWS Role ARN:
```bash
kubectl annotate serviceaccount --namespace ${KSA_NAMESPACE} ${KSA_NAME} \
  amazonaws.com/role-arn=${AWS_ROLE_ARN}
```

### GKE: Webhook deployment
- Create a k8s namespace for admission webhook:
```bash
kubectl apply -f manifests/webhook-namespace.yaml
```
- Create k8s Service Accounts to be used with the admission webhook:
```bash
kubectl apply -f manifests/webhook-service-account.yaml
```
- Define RBAC permissions for k8s Service Accounts to be used with the admission webhook. Create Cluster roles:
```bash
kubectl apply -f manifests/webhook-clusterrole.yaml
```
- Create cluster role bindings:
```bash
kubectl apply -f manifests/webhook-clusterrolebinding.yaml
```
- Create job for creating secrets with client certificate:
```bash
kubectl apply -f manifests/job.yaml
```
- Once the secret is created, we can create deployment and service for admission webhook:
```bash
kubectl apply -f manifests/webhook-deployment.yaml
```
```bash
kubectl apply -f manifests/webhook-service.yaml
```
- Configure admission webhook. Get the cluster's certificate-authority-data with the next command:
```bash
kubectl config view --raw --flatten -o json | jq -r '.clusters[] | select(.name == "'$(kubectl config current-context)'") | .cluster."certificate-authority-data"'
```
- Paste cluster's certificate-authority-data in `manifests/mutatingwebhookconfig.yaml` file in placeholder for `CA_BUNDLE`:
```yaml
      service:
        name: admission-webhook-svc
        namespace: webhook
        path: "/pods"
      caBundle: ${CA_BUNDLE} # place value here
```
- Finally, deploy mutating webhook configuration:
```bash
kubectl apply -f manifests/mutatingwebhookconfig.yaml
```

## Testing
- Create a k8s Pod configuration as shown below:
```bash
cat > test-pod.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  name: test-pod
  namespace: ${KSA_NAMESPACE}
  labels:
    admission.token-injector/enabled: "true"
spec:
  serviceAccountName: ${KSA_NAME}
  containers:
  - name: test-pod
    image: mikesir87/aws-cli
    command: ["tail", "-f", "/dev/null"]
EOF
```

- Apply pod configuration from YAML file:
```bash
kubectl apply -f test-pod.yaml
```

- Connect to the running k8s Pod:
```bash
kubectl exec -it test-pod -n application-namespace -- bash
```

- Run the following command in the Pod shell to check the AWS assumed role:
```bash
aws sts get-caller-identity
```

The output should look similar to the below:
```text
{
    "UserId": "AROAXXPBSFGLKUDFGHT7Q:token-injector-webhook-luwkompqhfewtygb",
    "Account": "531438381462",
    "Arn": "arn:aws:sts::531438381462:assumed-role/gke-reader-role/token-injector-webhook-luwkompqhfewtygb"
}
```
